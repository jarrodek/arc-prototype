(function() {
  'use strict';

  /* global HeadersBehaviors, CryptoJS */

  Polymer({
    is: 'wsse-support',
    behaviors: [
      HeadersBehaviors.FillSupportBehavior
    ],
    hostAttributes: {
      'header-support': 'x-wsse'
    },
    properties: {
      // User login
      login: String,
      // User password
      password: String,
      /**
       * A unique binary string generated for use in the WSSE hashing algorithm and useful to
       * help prevent against reply attacks. This value essentially represents a "request ID".
       */
      nonce: String,
      /**
       * Indicates to the authorization server the time when the request was created or signed
       * and can thus help prevent stale requests from being used at a later time.
       */
      date: String,
      // Nonce in Base64
      nonceAsBase64: {
        type: Boolean,
        value: true
      },
      // Default value is used to be able to apply auto generation when user come from saved form
      lastGeneratedNonce: {
        type: String,
        value: 'init'
      },
      // Default value is used to be able to apply auto generation when user come from saved form
      lastGeneratedDate: {
        type: String,
        value: 'init'
      },
      // True to generate nonce automatically
      autogenNonce: {
        type: Boolean,
        value: true
      },
      // True to generate timestamp automatically
      autogenTimestamp: {
        type: Boolean,
        value: true
      }
    },

    detached: function() {
      this.disableSupport();
    },

    attached: function() {
      this.enableSupport();
    },

    // Add an event to refresh digest automatically after each request
    enableSupport: function() {
      this.listen(document.body, 'ready', '_onResponseReady');
    },
    // Remove event that refresh the value after response ready.
    disableSupport: function() {
      this.unlisten(document.body, 'ready', '_onResponseReady');
    },

    /**
     * Handles a `ready` event fired on body.
     * If the source of the event is `ARC-REQUEST-CONTROLLER` (request ended) then
     * regenerate nonce and timestamp.
     */
    _onResponseReady: function(e) {
      if (e && e.target && e.target.nodeName === 'ARC-REQUEST-CONTROLLER') {
        this._refreshValue();
      }
    },

    // Opens the editor popup.
    provideSupport: function() {
      this._setCurrentValues(this._getCurrentValue());
      this.open();
    },

    _generateNonce: function() {
      var nonceChars = '0123456789abcdef';
      var result = '';
      for (var i = 0; i < 16; i++) {
        result += nonceChars.charAt(Math.floor(Math.random() * nonceChars.length));
      }
      return result;
    },
    // Returns current date in ISO-8601 format.
    _generateDate: function() {
      var date = new Date();
      return date.toISOString();
      // var yyyy = date.getUTCFullYear();
      // var mm = (date.getUTCMonth() + 1);
      // if (mm < 10) {
      //   mm = `0${mm}`;
      // }
      // var dd = date.getUTCDate();
      // if (dd < 10) {
      //   dd = `0${dd}`;
      // }
      // var hh = date.getUTCHours();
      // if (hh < 10) {
      //   hh = `0${hh}`;
      // }
      // var mn = date.getUTCMinutes();
      // if (mn < 10) {
      //   mn = `0${mn}`;
      // }
      // var ss = date.getUTCSeconds();
      // if (ss < 10) {
      //   ss = `0${ss}`;
      // }
      // return `${yyyy}-${mm}-${dd}T${hh}:${mn}:${ss}Z`;
    },
    // Analyse element properties to get current value
    _getCurrentValue: function() {
      var currentValue;
      if (this.model) {
        currentValue = this.model.get('item.value');
      } else if (this.target) {
        currentValue = this.target.value;
      } else {
        currentValue = this.value;
      }
      return currentValue;
    },
    // Sets values in form from current inpits in headers editor
    _setCurrentValues: function(currentValue) {
      if (!currentValue) {
        this.set('login', '');
        this.set('nonce', '');
        this.set('date', '');
        this.set('password', '');
        return;
      }

      var regex = /Username="(.*)", PasswordDigest="(.*)", Nonce="(.*)", Created="(.*)"/i;
      var matches = currentValue.match(regex);
      if (matches && matches.length === 5) {
        // Login
        this.set('login', matches[1]);
        // Nonce
        var nonce = matches[3];
        // Try to define is nonce is base64 or not
        try {
          nonce = CryptoJS.enc.Base64.parse(nonce).toString(CryptoJS.enc.Utf8);
          this.set('nonceAsBase64', true);
        } catch (e) {
          this.set('nonceAsBase64', false);
        }
        // Apply on form only if nonce is not last autogenerated one
        if (!this.lastGeneratedNonce || (this.lastGeneratedNonce !== 'init' &&
            this.lastGeneratedNonce !== nonce)) {
          this.set('nonce', nonce);
        }
        // Date
        // Apply on form only if date is not last autogenerated one
        if (!this.lastGeneratedDate || this.lastGeneratedDate !== 'init' &&
          this.lastGeneratedDate !== matches[4]) {
          this.set('date', matches[4]);
        }
      }
    },

    // Close the popup and cancel changes.
    _cancel: function(e) {
      this.cancel(e);
    },
    // Accept current values.
    _select: function() {
      var nonce;
      var date;
      if (this.autogenNonce) {
        this.nonce = '';
      }
      if (this.autogenTimestamp) {
        this.date = '';
      }

      if (this.nonce) {
        nonce = this.nonce;
        this.lastGeneratedNonce = '';
      } else {
        nonce = this._generateNonce();
        this.lastGeneratedNonce = nonce;
      }
      if (this.date) {
        date = this.date;
        this.lastGeneratedDate = '';
      } else {
        date = this._generateDate();
        this.lastGeneratedDate = date;
      }
      var toEncode = nonce + date + this.password;
      var sha1 = CryptoJS.SHA1(toEncode);
      var digest = sha1.toString(CryptoJS.enc.Base64);
      var nonce64 = nonce;
      if (this.nonceAsBase64) {
        nonce64 = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(nonce64));
      }
      this.setValue('UsernameToken Username="' + this.login + '", PasswordDigest="' + digest +
        '", Nonce="' + nonce64 + '", Created="' + date + '"');
    },

    _refreshValue: function() {
      this._setCurrentValues(this._getCurrentValue());
      this._select();
    },

    authTogglePassword: function(e) {
      var input = this.$.authDialogPassword;
      var icon = e.target;
      if (input.type === 'password') {
        input.type = 'text';
        icon.icon = 'visibility-off';
      } else {
        input.type = 'password';
        icon.icon = 'visibility';
      }
    }
  });
})();
